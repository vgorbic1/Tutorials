##Web Services
According to the W3C, Web services provide a standard means of interoperating between different software applications, running on a variety of platforms and/or frameworks.

####SOAP
SOAP was previously an acronym that stood for Simple Object Access Protocol; however, version 1.2 of the W3C standard for SOAP dropped the acronym altogether. So, technically, SOAP simply stands for SOAP! SOAP is a powerful tool for communication between disparate systems, as it allows the definition and exchange of complex data types in both the request and response, as well as providing a mechanism for various messaging patterns, the most common of which is the Remote Procedure Call (RPC).

SOAP is intrinsically tied to XML, because all messages sent to and from a SOAP server are sent in a SOAP envelope that is an XML wrapper for data read and generated by the SOAP server. Creating the XML for this wrapper canbe a tedious process; therefore, many tools and external PHP libraries have been created to aid developers in the cumbersome process of forming SOAP requests and reading SOAP server responses. PHP 5 simplifies this process with its SOAP extension, which makes the creation of both servers and clients
very easy.

A SOAP Web service is defined by using a Web Service Description Language (WSDL, pronounced “whisdl”) document. This, in turn, is yet another XML document that describes the function calls made available by a Web service, as well as any specialized data types the service needs.

**Accessing SOAP-Based Web Services**

All you really need to do is provide ```SoapClient``` class with the path to a WSDL file, and it will automatically build a PHP-friendly interface that you can call directly from your scripts.
```php
try {
  $client = new SoapClient('http://api.example.org/search.wsdl');
  $results = $client->doSearch($key, $query, 0, 10, FALSE, '', FALSE, ', ', '');
  foreach ($results->resultElements as $result) {
    echo '<a href="' . htmlentities($result->URL) . '">';
    echo htmlentities($result->title, ENT_COMPAT, 'UTF-8');
    echo '</a><br/>';
  }
} catch (SoapFault $e) {
  echo $e->getMessage();
}
```
SoapClient uses the WSDL file to construct an object mapped to the methods defined by the web service; thus, $client will now provide the method doSearch() and any other specified methods. In our example, the script invokes the doSearch() method to return a list of search results. If SoapClient encounters any problems, it will throw an exception, which we can trap as explained in the Errors and Exceptions.

If you are accessing a SOAP service that does not have a WSDL file, it is possible to create a SOAP client in non-WSDL mode by passing a NULL value to the SoapClient constructor instead of to the location of the WSDL file. In this case, you will have to pass the URI to the Web service’s entry point as part of the second parameter.

```SoapClient``` provides special methods that make it possible to debug messages sent to and received from a SOAP server. These messages can be turned on by setting the trace option to 1 when instantiating a SOAP client object. This, in turn, will make it possible for you to access the raw SOAP headers and envelope bodies.
```php
$client = new SoapClient(
'http://api.example.org/search.wsdl', ['trace' => 1]
);
$results = $client->doSearch(
$key, $query, 0, 10, FALSE, '', FALSE, ', ', ''
);
echo $client->__getLastRequestHeaders();
echo $client->__getLastRequest();
```

**Creating SOAP-Based Web Services**

Just as SoapClient simplifies the task of building a Web service client, the SoapServer class performs all the background work of handling SOAP requests and responses. When creating a SOAP server, you simply start with a class that contains the methods you wish to make available to the public through a Web service and use it as the basis of a SoapServer instance.

Simple SOAP server:
```php
class MySoapServer {
  public function getMessage() {
    return 'Hello, World!';
  }

  public function addNumbers($num1, $num2) {
    return $num1 + $num2;
  }
}
```
When creating a SOAP server with SoapServer, you must decide whether
your server will operate in WSDL or non-WSDL mode. At present, SoapServer
will not automatically generate a WSDL file based on an existing PHP class,
although this feature is planned for a future release. For now, you can either
create your WSDL files manually—usually an incredibly tedious task— or there
are tools that will generate them for you; you can also choose not to provide
a WSDL file at all. For the sake of simplicity, our example SOAP server will
operate in non-WSDL mode.

Once we have created the server, we need to inform it of the class that we
want the web service to be based on. In this case, our SOAP server will use the
MySoapServer class. Finally, to process incoming requests, call the handle()
method:
```php
$options = ['uri' => 'http://example.org/soap/server/'];
$server = new SoapServer(NULL, $options);
$server->setClass('MySoapServer');
$server->handle();
```
While this SOAP service works just fine in non-WSDL mode, it is important
to note that a WSDL file can be helpful both for users of the service and for
the SoapServer object itself. For users, a WSDL file helps expose the various
methods and data types available. For the server, the WSDL file allows the
mapping of different WSDL types to PHP classes, thus making the handling of
complex data simpler.

The following example shows how a client might access the SOAP server
described in this section. Notice how the client is able to access the
getMessage() and addNumbers() methods of the MySoapServer class:
```php
$options = [
'location' => 'http://example.org/soap/server/server.php',
'uri' => 'http://example.org/soap/server/'
];
$client = new SoapClient(NULL, $options);
echo $client->getMessage() . "\n";
echo $client->addNumbers(3, 5) . "\n";
```

####REST
Representational State Transfer, or REST, is a Web service architectural
style in which the focus is on the presence of resources in the system. Each
resource must be identified by a global identifier—a URI. To access these
resources, clients communicate with the REST service by HTTP, and the
server responds with a representation of the resource. This representation is
most often in the form of JSON, or XML, or sometimes even HTML. Services
that use the REST architecture are referred to as RESTful services; those who
use or provide RESTful services are sometimes humorously referred to as
RESTafarians.

In a loose sense, Web sites that provide RSS and RDF feeds provide a RESTful service. The entire Web itself may be thought of as following a RESTful architecture, with myriad resources and only a few actions to interact with them: GET, POST, PUT, HEAD, etc. In general, however, RESTful Web services allow standard GET requests to a resource and, in return, send an JSON or XML response. These services are not discoverable, so most providers have welldocumented APIs.

Since RESTful Web services are not discoverable, do not provide a WSDL, and have no common interface for communication, there is no single REST class provided in PHP to access all RESTful services; however, most RESTful services respond with JSON data, which is easily parsed in PHP.

Typically, a basic HTTP client (e.g., Guzzle) or even streams and the ```json_decode()``` function are all we need to converse with a REST API—which probably accounts for their rise in popularity. For the server-side, a simple echo ```json_encode()``` is all that is needed. A common use for REST Web services is for client-side AJAX requests.

